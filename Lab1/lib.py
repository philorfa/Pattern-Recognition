# -*- coding: utf-8 -*-
"""lib.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_ewe3NXlXOs4TisPG7Y4T04Cl8lEXZxr
"""

from sklearn.base import BaseEstimator, ClassifierMixin
import numpy as np
import matplotlib.pyplot as plt
import math
from sklearn.model_selection import KFold


def show_sample(X, index):
    try:
            image=np.reshape(X[index],(16,16))
            plt.imshow(image,cmap='gray')
    except:
            raise NotImplementedError


def plot_digits_samples(X, y):
    try:
            fig = plt.figure(figsize=(16,16))
            for i in range(10):
                image=X[np.random.choice(np.where(y==i)[0])]
                image=np.reshape(image,(16,16))
                plt.subplot(5, 2, 1 + i)
                plt.imshow(image,cmap='gray')
            plt.show()
    except:
            raise NotImplementedError


def digit_mean_at_pixel(X, y, digit, pixel=(10, 10)):
    try:
            list_of_index =np.where(y==digit)[0]
            new = np.asarray([X[i] for i in list_of_index])
            elements=[]
            for i in range(len(new)):
                new_reshape=np.reshape(new[i],(16,16))
                elements.append(new_reshape[pixel[0]][pixel[1]])
            result=np.mean(elements)
            return result
    except:
            raise NotImplementedError



def digit_variance_at_pixel(X, y, digit, pixel=(10, 10)):
    try:
            list_of_index =np.where(y==digit)[0]
            new = np.asarray([X[i] for i in list_of_index])
            elements=[]
            for i in range(len(new)):
                new_reshape=np.reshape(new[i],(16,16))
                elements.append(new_reshape[pixel[0]][pixel[1]])
            result=np.var(elements)
            return result
    except:
            raise NotImplementedError



def digit_mean(X, y, digit):
    try:
            list_of_index = np.where(y==digit)[0]
            new = np.asarray([X[i] for i in list_of_index])  
            new_mean=np.mean(new,axis=0)
            return new_mean
    except:
            raise NotImplementedError



def digit_variance(X, y, digit):
    try:
            list_of_index =np.where(y==digit)[0]
            new = np.asarray([X[i] for i in list_of_index])  
            new_mean=np.var(new,axis=0)
            return new_mean
    except:
            raise NotImplementedError


def euclidean_distance(s, m):
    try:
            return np.linalg.norm(s - m)
    except:
            raise NotImplementedError


def euclidean_distance_classifier(X, X_mean):
    try:
            label = -1
            err = math.inf
            for i in range(len(X_mean)):
                dist = euclidean_distance(X,X_mean[i])
                if dist < err :
                    label = i
                    err = dist
            return label
    except:
            raise NotImplementedError



class EuclideanDistanceClassifier(BaseEstimator, ClassifierMixin):  
    """Classify samples based on the distance from the mean feature value"""

    def __init__(self):
        self.X_mean_ = None


    def fit(self, X, y):
            try:
                mean_arrays=[]
                for i in range(int(np.amax(y)+1)):
                    mean_arrays.append(digit_mean(X,y,i))
                    m_array=np.array(mean_arrays)
                self.X_mean_= m_array
                return self
            except:
                raise NotImplementedError


    def predict(self, X):
            try:
                X=np.array(X)
                if(X.ndim==1):
                    label= euclidean_distance_classifier(X, self.X_mean_)
                    return label
                else:
                    labels=[]
                    for i in range(X.shape[0]):
                        labels.append(euclidean_distance_classifier(X[i], self.X_mean_))
                    labels=np.array(labels)
                    return labels
            except:
                raise NotImplementedError
    
    def score(self, X, y):
            try:
                err=np.subtract(self.predict(X),y)
                count= np.count_nonzero(err==0)
                accuracy=count/len(X)
                return accuracy
            except:
                raise NotImplementedError


def evaluate_classifier(clf, X, y, folds=5):
    try:
            kf = KFold(n_splits=folds)  
            acc=[]
            for train_index, test_index in kf.split(X):
                X_train, X_test = X[train_index], X[test_index]
                y_train, y_test = y[train_index], y[test_index]
                clf.fit(X_train,y_train)
                acc.append(clf.score(X_test,y_test))
            acc=np.array(acc)
            return np.mean(acc)
    except:   
            raise NotImplementedError

